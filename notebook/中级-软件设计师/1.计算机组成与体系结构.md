# 一.计算机组成与体系结构

## 1.进制转换的计算方法

### 1.1 R进制转十进制的方法

- **按权展开法**
  对每一位数字分别进行计算。
  若进制数为R，
  当前位与小数点的距离（小数点左侧向左从0开始，小数点右侧向右从-1开始）为k，
  该位的值为n，
  则该位转换为十进制的值为：$R^k\times n$  
  例如：
  二进制：$101.01 = 2^2\times 1 + 2^0\times 1 + 2^{-2}\times 1 = 5.25$  
  七进制：$604.01 = 7^2\times 6 + 7^0\times 4 + 7^{-2}\times 1 = 298\frac{1}{49}$

### 1.2 十进制转R进制的方法

- 短除法
  将原数值一直除以R，记录每次除之后的余数，直到最后的商小于进制数R。
  使最后的商作为第一位数，后续将之前获得的余数倒排，便得到转换后的R进制数。
  例如：
  31转为二进制：
  ```
  2 | 31 ... 1
  2 | 15 ... 1
  2 | 7  ... 1
  2 | 3  ... 1
      1
  故31转二进制为11111
  ```
	81转为8进制：
  ```
  8 | 81 ... 1
  8 | 10 ... 2
      1
  故81转八进制为121
  ```

### 1.3 二、八、十六进制互相转换的方便方法

- 三个二进制位对应一个八进制位，四个二进制位对应一个十六进制位，因此若要将二进制转为八进制或十六进制，只需每三位或四位进行分组，分别转换后即可得到目标数。
  例：
  二进制10001110转换为八进制：
  ```
  10 | 001 | 110
  =
  2  |  1  |  6
  =
  216
  ```
  二进制10001110转换为十六进制：
  ```
  1000 | 1110
  =
  8    | e
  =
  8e
  ```

## 2.计算机数据编码


| 数值  |     1     |    -1     |      1-1      |
| :-: | :-------: | :-------: | :-----------: |
| 原码  | 0000 0001 | 1000 0001 | 1000 0010（有误） |
| 反码  | 0000 0001 | 1111 1110 | 1111 1111（-0） |
| 补码  | 0000 0001 | 1111 1111 | 0000 0000（0）  |
| 移码  | 1000 0001 | 0111 1111 | 1000 0000（0）  |

### 2.1 原码

- 原理：
  > 将数转为二进制，存入一个字节（8个bit）中。  
  > 其中最左边一位是符号位，0表示正数，1表示负数。
- 取值范围：  
	> $-(2^{n-1}-1)$ ~ $2^{n-1}-1$  
	> n为比特数，例如一个字节的话n为8。  
	> 一个字节数的范围就是 -127 ~ 127。
- 缺陷：  
	> 没法直接在计算机中运算，例如正数和负数相加没法直接使用与运算。

### 2.2 反码

- 原理：  
	> 正数与原码相同。  
	> 负数在原码的基础上，符号位不变，数值位全部取反。
- 取值范围：  
	> 与原码相同。  
  > $-(2^{n-1}-1)$ ~ $2^{n-1}-1$  
	> n为比特数，例如一个字节的话n为8。  
	> 一个字节数的范围就是 -127 ~ 127。
- 缺陷：  
	> 会存在0和-0的问题。

### 2.3 补码

- 原理：  
	> 正数与原码相同。  
	> 负数在反码的基础上加1。
- 取值范围：  
	> $-2^{n-1}$ ~ $2^{n-1}-1$  
	> n为比特数，例如一个字节的话n为8。  
	> 一个字节数的范围就是 -128 ~ 127。
- 说明：  
	> 现代计算机基本都使用补码进行计算。
- 优点：  
	> 解决了-0的问题，使得正数和负数可以直接使用加法运算。

### 2.4 移码

- 原理：  
	> 在补码的基础上，符号位颠倒。  
	> 使得整个字节的最小值为0000 0000，最大值为1111 1111，零为1000 0000。
- 作用：  
	> 可以方便的比较两个数的大小。  
	> 用于表示浮点数的阶码（指数）。

### 2.5 浮点数

- 浮点数表示方法：  
	> $N=M\times R^e$  
	> M是尾数，e是指数，R是基数。  
	> 类似科学计数法。
- 例：  
	> $1.119\times 10^3$  
	> 1.119是尾数，3是指数，10是基数。
- 运算方法：  
	例如计算 1000 + 119：  
	$1.0\times 10^3+1.19\times 10^2$  
	1. 对阶  
		> 将较小的指数化为较大的指数
		> $1.0\times 10^3+1.19\times 10^2=$
		> $1.0\times 10^3+0.119\times 10^3$
	2. 尾数计算
		> $1.0\times 10^3+0.119\times 10^3=$
		> $1.119\times 10^3$
	3. 结果格式化
		> 若结果的尾数大于10或小于1，则需要格式化，使尾数为1位数。
		> 例如：若结果为 $0.0199\times 10^4$，则需要格式化为 $1.99\times 10^2$
		
## 3. 计算机结构

### 3.1 计算机结构意义上的主机构成

- 主存储器（内存）
- CPU（中央处理器）

### 3.2 CPU的构成

- 运算器
	- 算数逻辑单元 ALU
		- 与运算相关
	- 累加寄存器 AC
		- 通用寄存器，存储运算中相应的值
	- 数据缓冲寄存器 DR
		- 对内存储器进行读写时用于暂存数据
	- 状态条件寄存器 PSW
		- 存储运算过程中相关的标志位（进位、溢出、中断等）
- 控制器
	- 程序计数器 PC
		- 标识当前运行的指令位置
	- 指令寄存器 IR
	- 指令译码器
	- 时序部件

### 3.3 计算机体系结构分类-flynn分类法

- 单指令流单数据流 SISD
	- 结构
		- 控制部分：一个
		- 处理器：一个
	- 代表
		- 单处理器系统
- 单指令流多数据流 SIMD
	- 结构
		- 控制部分：一个
		- 处理器：多个
	- 特性
		- 各处理器以异步的形式执行同一条指令（只是处理的数据不同）
	- 代表
		- 并行处理机
		- 阵列处理机
		- 超级向量处理机
- 多指令流单数据流 MISD
	- 结构
		- 控制部分：多个
		- 处理器：一个
	- 特性
		- 被证明不可能、不实际
- 多指令流多数据流 MIMD
	- 结构
		- 控制部分：多个
		- 处理器：多个
	- 特性
		- 能够实现作业、任务、指令等各级全面并行
		- 多个计算机、或多个处理器组成集群完成任务
	- 代表
		- 多处理机系统
		- 多计算机
		
### 3.4 计算机指令类型CISC与RISC

- CISC（复杂指令集）
	- 指令特点
		- 指令数量多
		- 指令长度可变
		- 指令使用频率差别大
	- 寻址方式
		- 支持多种
	- 实现方式
		- 微程序控制技术（微码）
	- 特点
		- 研制周期长
- RISC（精简指令集）
	- 指令特点
		- 指令数量少
		- 指令定长
		- 指令使用频率接近
		- 大部分为单周期指令
		- 大量使用寄存器
		- 只有load/store操作内存
	- 寻址方式
		- 支持方式少
	- 实现方式
		- 增加了通用寄存器
		- 硬布线逻辑控制为主
		- 适合采用流水线
	- 特点
		- 优化编译
		- 有效支持高级语言